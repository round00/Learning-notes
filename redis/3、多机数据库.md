
# 第十五章 复制
redis中，用户可以通过`SLAVEOF命令`或者`slaveof选项`(5.0.5版本我并没有找到这个选项)让一个服务器去复制另外一个服务器。主从服务器的数据库中将保存。  
旧版(2.8以前)复制包括两个部分：

1. 同步：将从服务器的状态更新至当前主服务器的状态。
2. 命令传播：主服务器数据库进行修改后，传播命令使主从恢复一致。

同步的步骤：

1. 从服务器向主服务器发送`SYNC`命令。
2. 主服务器收到`SYNC`命令后，立刻执行`BGSAVE`在后台生成一个RDB文件，并且在此之后的写命令都记录到一个缓冲区中。
3. 主执行完BGSAVE后，将RDB文件发给从。从接收并载入它，从的状态更新为主执行BGSAVE时的状态。
4. 主将记录在缓冲区中的写命令发给从，从执行这些写命令，将状态更新到主现在的状态。

这个版本的复制的**缺陷**是：当从断线重连后，还是会从SYNC命令开始，在进行一次完整的复制过程。这样严重浪费了计算机资源，效率很低。

新版本(2.8开始)用PSYNC代替SYNC命令，PSYNC有以下两种模式：

1. 完整重同步：基本和旧版SYNC一样。
2. 部分重同步：主要来处理断线重连的情况。从重连上主后，如果条件允许，主将断线这段时间内的写命令发送给从。这样就能恢复一致了。

部分重同步由以下三个部分构成：

1. 主服务器的**复制偏移量**和从服务器的复制偏移量
2. 主服务器的**复制积压缓冲区**
3. 服务器的**运行ID**(run ID)

主和从都会维护一个**复制偏移量**：

- 主向从传播N个字节的数据时，自己的offset就会增加N
- 从接收主N个字节的数据时，自己的offset就会增加N

可以通过对比偏移量得知主从状态是否一致。

复制积压缓冲区是主服务器维护的一个**固定长度**的**队列**，默认大小1MB。固定长度的意思是队列达到容量上限后，每进一个就要出一个。  
主在将数据传播给从的同时，还会将数据加入到复制积压缓冲区中，并且复制积压缓冲区会为队列中的每个字节记录相应的偏移量。

PSYNC的过程：

1. 从重连主后，向主发送PSYNC，同时携带自己的复制偏移量offset。
2. 主检查offset是否还在自己的积压缓冲区中，不存在则进行完全重同步。否则的话向从发送+CONTINUE,标识将进行部分重同步进行复制。
3. 主将offest后的所有内容发送给从。
4. 从接收内容并执行，主从恢复一致。

redis配置中的`repl-backlog-size`选项来调整默认积压缓冲区的大小。这个大小可以由`seconds * write_size_per_second`这个公式来估算`seconds`是秒数，后者是每秒写入的数据量。想保险一点的话，可以设置为这个估算值的两倍。

实现部分重同步还需要用到**运行ID**：

- 每个redis服务器都会有一个runID，无论主从。
- runID是一个随机40位十六进制字符串。

从服务器初次连上主服务器时，主会把自己的runID发给从，从持有这个ID用来在之后断线重连时发给主验证是否是断线之前的主服务器。如果不是原主的话，那么会执行完全重同步。

PSYNC的参数：

- 如果之前没有连结过主服务器的情况，执行 `PSYNC ？ -1` 命令进行完全重同步。
- 如果之前已经连接过的话，恢复时用 `PSYNC <runid> <offset>`。runid是之前保存的主服务器的runid，offset是从服务器的复制偏移量。

服务器返回有三种结果：

1. `+FULLRESYNC <runid> <offset>`表示完全重同步
2. `+CONTINUE`表示部分重同步
3. `-ERR`表示主服务器版本低于2.8，无法识别PSYNC命令
##
redis复制的实现如下：

1. **客户端**向**从服务器**发送 `SLAVEOF <host> <port>` 命令，从服务器首先会将地址和端口存到`redisServer.masterhost` 和 `redisServer.masterport`，然后返回OK给客户端。之后准备开始执行复制操作。
2. 从服务器向主服务器的套接字发起连接，成功后从服务器创建专门的文件事件处理器来进行后续工作。主服务器为从服务器创建客户端状态结构。从相对于主来说就是客户端。
3. 从向主发一个PING命令，确定是否能进行通信，主的回复有以下几种情况：
	1. 主返回了一个回复，但是由于某些原因从没有读到，那么从将断开连接，再重新发起连接
	2. 主返回了一个错误，表示此时不能执行复制操作，从断开并重新发起连接。
	3. 主返回PONG，执行下一个步骤。
4. 如果从服务器设置了 `masterauth`选项，那么向主发送auth 命令进行验证。有以下几种可能情况：
	1. 如果主没设置 `requirepass` 且从也没设置 `masterauth`，那么跳过这一步
	2. 主从都设置了。密码对则工作继续，否则主返回 `invaild password` 错误
	3. 主设置了从没有，主返回 `NOAUTH` 错误。
	4. 主没有从有，主返回 `no password is set` 错误
5. 从向主发自己监听的端口号 `REPLCONF listening-port <port>`。主会把从的端口号记录再`redisClient.slave_listening_port`中。`INFO replication`命令可以查看主从复制的信息。
6. 从向主发送PSYNC开始同步。主服务器成为从服务器的客户端，目的是发送缓冲区或者积压缓冲区中的命令给从。
7. 完成同步后，进入命令传播阶段，主不断发命令给从，从不断接收并执行。
8. 以上就是复制的完整实现。

命令传播阶段，从会默认以每秒一次的频率向主发送心跳包：`REPLCONF ACK <replication_offset>`。有三个用途：

1. 检测主从连接状态
2. 辅助实现min-slave选项：再一定不良好条件下，主会拒绝执行写操作。
3. 检测命令丢失：如果偏移量不对，则主重发从缺少的命令

# 第十六章 Sentinel
**Sentinel**(哨兵)是redis**高可用性**的解决方案：由一个或多个Sentinel实例组成Sentinel系统，来监视任意多个主服务器和其从服务器。当主下线时，自动将某个从服务器升级为主服务器，继续运行。  
故障转移操作：

- Sentinel系统挑选一个从，将其升级为主
- 向旧主下的所有从发送复制命令，使他们成为新主的从，当所有从都开始复制新主时，操作完成
- 如果旧主重新连接，那么它也成为新主的从。

启动Sentinel的命令

	redis-sentinel <path to your sentinel.conf> 
或者

	redis-server <path to your sentinel.conf> --sentinel
其实redis-sentinel只是指向redis-server的软链接，在redis-server程序内部会判断以什么方式启动的。

## Sentinel的启动过程：
### 1. 初始化服务器。
Sentinel只是一个运行在特殊模式下的redis服务器而已。不过Sentinel的工作和普通redis服务器的工作不同，初始化方式也不一样。  

1. Sentinel在启动时不会载入RDB或者AOF文件，因为它并不是一个数据库。
2. Sentinel使用专用的代码，例如默认端口号，命令表`sentinelcmds`等。Sentinel命令表中比普通redis的命令表中的命令少很多，现在这个版本3.0只有七个命令可用。
3. 服务器会初始化一个`sentinel.c/sentinelState` 结构用来存储Sentinel的状态。
4. 初始化Sentinel结构中的`masters`字典。这个字典记录了所有被Sentinel监视的主服务器的信息。键是主的名字，值是`sentinel.c/sentinelRedisInstance`,代表一个被Sentinel监视的redis服务器实例，可以是主、从或者另外一个sentinel。masters字典是由sentinel启动时的配置文件指定的。
5. 创建**两个**连向被监视主服务器的**异步**网络连接，Sentinel成为主服务器的客户端。
	1. 一个是命令连接，用于向主服务器发送命令并接收回复
	2. 另一个是订阅连接，订阅主服务器的`__sentinel__:hello`频道
### 2. 获取主服务器信息
Sentinel会以默认每10秒一次的频率向主服务器发送INFO命令，通过分析INFO命令的回复可以得到以下信息：

1.  主服务器的信息，runID和角色
2.  主下面从的信息，这样用户无须提供从服务器的信息给Sentinel，就可以自动发现从服务器

分析出信息后更新主服务器实例结构中的主的信息，和`slaves`字典，这个字典的键是从的名字(ip:port),值是从服务器的实例结构(flags=SRI_SLAVE)。

### 3. 获取从服务器信息
创建从服务器的实力结构后，Sentinel还会创建到从服务器命令和订阅连接。创建连接后Sentinel又会以每10秒1次的频率向从服务器发送INFO命令，获得从服务器的相关信息，然后对从的实例进行更新。

### 4. 向主和从发送信息
默认情况下，Sentinel会以每两秒一次的频率向主和从发送以下命令：

	PUBLISH __sentinel__:hello "<s_ip>,<s_port>,<s_runid>,<s_epoch>,<m_name>,<m_ip>,<m_port>,<m_epoch>"
其中s_开头的是Sentinel的信息，m_开头的是主服务器的信息(如果接收者是从就是它所复制的主的信息)。

### 5. 接收来自主和从的频道信息
对于每个和Sentinel连接发服务器，Sentinel既能通过命令连接向服务器的__sentinel__:hello频道发送信息，也能通过订阅频道从该频道接收消息。  
对于监视同一个主服务器的多个Sentinel，一个Sentinel发送的信息会被其他Sentinel收到，并且更新信息。因为所有的Sentinel都会在同一个__sentinel__:hello频道里，所以发向该频道的信息大家都会收到。  
频道信息的作用如下：

1. 更新主服务器实例中的`sentinels`字典，该字典键是sentinel的名字(ip:port)，值是Sentinel的实例结构。
2. 创建连向其他Sentinel的连接。当发现新的Sentinel连向同一个主服务器时，会为该实例创建一个结构。最终各个Sentinel之间都会建立起一个命令连接网络，都知道对其他Sentinel的存在。 sentinel之间不会建立订阅连接。

### 6. 检测主观下线
默认情况下Sentinel会以每秒一次的频率向其他服务器（主、从、其他Sentinel）发送PING命令，来判断对方是否在线。Sentinel配置中的`down-after-millseconds`选项指定了Sentinel判断实例主观下线所需的时间长度。  
如果一个实例在选项指定毫秒内连续返回无效回复，那么Sentinel判定对方下线，修改对应实例结构中的flags=SRI_S_DOWN，表示这个实例已经进入**主观下线**状态。  
Sentinel可以判定主、从、其他Sentinel为主观下线状态。并且各个Sentinel判定主观下线的时间可能不同。

### 7. 检查客观下线
当Sentinel判定某服务器为主观下线后，会向其他Sentinel询问该机器是否在线，如果得到该服务器主观下线的数量达到一定数目后，就判定该服务器客观下线。

1. 向其他Sentinel发送命令，进行询问：

	SENTINEL is-master-down-by-addr <ip> <port> <current_epoch> <runid>
2. 接收其他Sentinel的询问命令，然后去对应的结构实例中查看状态是否为主观下线，并回复对方：
	1. `<down-state>` 	1=已下线，0=未下线
	2. `<leader-runid>` *或者目标Sentinel的局部领头runID。\*号表式当前是询问是否下线
	3. `<leader-epoch>` 用于选举局部领头，上一个参数非*时有效。
3. 根据其他Sentinel的回复统计主观下线的数目，当这个数目达到配置的数量`quorum`时，就修改该服务器实例结构中的flags=SRI_O_DOWN,表示**客观下线**。

### 8. 选举领头
当判定出一个主服务器客观下线时，监视它的Sentinels会选举出一个**领头**来进行故障转移操作。

- 每个Sentinel都会向其他服务器发消息申请自己成为领头
- Sentinel收到的第一个申请会同意，之后的都会拒绝
- 超过半数同意的Sentinel成为领头
- 没有选举成功，则再进行一次选举

### 9. 故障转移
对客观下线的主机进行故障转移操作：

1. 选出新的主服务器，然后执行`SLAVEOF no one`成为主服务器。在下线主的所有从中进行过滤：
	1. 必须是在线的
	2. 最近5秒内必须回复过Sentinel
	3. 与旧主断开连接时间小于`down-after-millseconds*10`毫秒

	在剩下的从中按照优先级、偏移量和运行ID进行选择。
2. 修改其他从服务器的复制目标，向其他从发送SLAVEOF命令，使他们成为新主的从服务器。
3. 旧主上线后，向它发送SLAVEOF命令，使他成为新主的从服务器。

# 第十七章 集群
redis集群是redis提供的分布式数据库方案，集群通过分片来进行数据库共享，并提供复制和故障转移功能。
## 1、节点
一个redis集群由多个节点组成，刚开始的时候每个节点都是独立的，处于一个只包含自己的集群中。将一些几点连接起来可以构成一个包含多个节点的集群。通过以下命令可以让两个节点握手，建立一个集群：

	CLUSTER MEET <ip> <port>
### 1. 启动节点
一个节点就是运行在集群模式下的redis服务器，在启动时根据`cluster-enable`选项来判断是否以集群模式启动。集群模式下redis会继续使用所有在单机模式中使用的服务器组件。并且会增加在集群模式下才使用的数据结构，这些结构都在`cluster.h`里。  

### 2. 集群数据结构
1. `clusterNode`结构保存了一个节点的当前状态，例如节点的创建时间、节点的名字、节点当前配置纪元、ip、port等。
2. `clusterLink`结构保存了连接节点所需的有关信息，比如结套接字描述符、输入输出缓冲区、连接的节点结构等。
3. 每个节点都保存着一个`clusterState`结构。这个结构记录了当前节点的视角下集群目前所处的状态，例如集群在线或者下线、集群节点数等

### 3. CLUSTER MEET命令
通过向某个节点A发送`CLUSTER MEET <ip> <port>`命令，使另外一个节点B成为当前节点所在集群中的一员。此命令的执行过程如下：

1. 节点A为B创建一个clusterNode结构，并将该结构添加到自己的clusterNode.nodes字典里。
2. 节点A根据CLUSTER MEET命令指定的ip和port向B发送一条MEET消息。
3. B接收MEET消息，并为A创建clusterNode结构添加到自己的clusterNode.nodes字典里。
4. B向A返回一条PONG消息。
5. A接收PONG，知道了B已经收到了MEET消息。
6. A向B发送一条PING。
7. B接收PING,B知道A已经收到PONG，握手完成

A和B交互握手完成后，A会将B的信息通过`Gossip协议`传播给集群中的其他节点，其他节点也和B进行握手。然后B就彻底融入集群了。

## 2、槽指派
集群通过分片的方式来保存键值对。集群的整个数据库被分为16384个槽数据库中的每个键都属于这些槽之一。集群中的每个节点都可以处理0个或16384个槽。并且这16384个槽都有在处理时集群才算是上线(ok),否则就是下线状态(fail)。
节点的槽指派信息包存在`clusterNode.slots`和`clusterNode.numslot`中.前者是以类似bitmap的方式存储的。  
各个节点之间还会互相发消息通知其他节点自己有哪些槽。接收到其他节点发来的消息后，会把其他节点的槽信息存到对应的clusterNode实例里。  
`clusterState.slots`会记录每个槽的指派节点。`clusterNode.slots`记录的是当前节点指派的槽是哪些。  
增加指派槽的命令如下：

	CLUSTER ADDSLOTS <slot> [slot ...]
在命令行客户端下不支持按区间分配槽，可以用shell脚本 + redis-cli命令来实现，shell脚本如下

	for i in {10001..16383};do
		redis-cli -c -p 7002 cluster addslots $i
	done

此命令首先会检查参数中的槽是否都是未指派的，只要存在一个已指派的，就返回错误。否则将槽指派给当前节点。

## 3、在集群中执行命令
在对数据库中的16384个槽都指派节点后，集群就上线了。客户端就可以向集群中的节点发送消息了。接收命令的客户端会计算出命令的键属于哪个槽，并检查该槽是否指派给自己：

1. 指派给了当前节点，那么当前节点直接操作
2. 指派给了其他节点，则当前节点向客户端返回**MOVED错误**，引导客户端转向(redirect)正确的节点。

计算槽位的方法如下：

	slot_number(key) = CRC(key) & 16384
	CRC()是计算CRC-16校验和
查看键槽位的命令：
	
	CLUSTER KEYSLOT msg
当节点发现槽位并非是自己在负责的时候，就向客户端返回一个MOVED错误，格式如下：

	MOVERD <slot> <ip>:<port>
节点保存键值对和过期时间的方式和单机数据库的方式完全相同。不同的地方在于节点只能使用0号数据库，而单机无此限制。  
`clusterState.slots_to_keys`保存了槽号和键的关系，这是一个跳跃表。

## 4、重新分片
重新分片操作可以将任意数量已经指派给某个节点的槽重新分配给新节点，并且相关槽所属的键值对也会从源节点被移动到目的节点。

实现步骤：
1. CLUSTER SETSLOT <slot> IMPORTING <src_runID>		#to dest node
2. CLUSTER SETSLOT <slot> migrating <dest_runID>	#to src node
3. CLUSTER GETKEYSINSLOT <slot> <count>				#to src node
4. MIGRATE <dest_ip> <dest_port> <key> 0 <timeout>	#to src node
5. CLUSTER SETSLOT <slot> NODE <dest_runID>			to every node in cluster

## 5、ASK错误
在重新分片的过程中，迁移源槽内的键到目的地时如果某个键已经被迁移到目的地，而此时客户端向源去请求这个键，那么就会生成ASK错误，引导客户端转向目的地。

1. `clusterState.importing_slots_from[16384]`记录了当前节点正在从其他节点导入槽。如果importing_slots_from[i]不为空，指向一个clusterNode结构，就表示当前节点正从importing_slots_from[i]节点导入槽i。
2. `clusterState.migrating_slots_to[16384]`记录了当前节点正在迁移至其他节点的槽。
3. 如果客户端请求key，且key的槽由当前节点负责。如果在数据库中没找到key，那么去migrating_slots_to看一下是否该槽正在被迁移，如果是的话，就向客户端发送一个**ASK错误**。

如果槽i正在从A节点迁移向B节点，当客户端向A请求key时，key已经在B节点了，那么A会收到ASK错误，如果这时候客户端立刻去B请求，那么客户端又会收到MOVED错误。这是因为现在**B还没负责槽i**。  
这种情况可以在客户端向B请求key前，先往B发一条`ASKING命令`，打开B中的`REDIS_ASKING`标志，然后再向B请求key，B就会破例一次让它请求到。

**ASK错误**和**MOVED错误**的区别：

- MOVED错误表示key对应的槽不归自己管
- ASK表示key对应的槽本来该自己管，但是槽中的key已经给别人了，即key不归自己管了。

## 6、复制与故障转移
redis集群中的节点也分为主节点和从节点。主节点用于处理槽，而从节点复制主节点。在主节点下线时，从节点将接管原主节点负责的槽并继续处理命令请求。当原主节点重新上线后，复制新的主节点。
### 1. 设置从节点
向一个节点A发送：

	CLUSTER REPLCATE <node_id>
可以使节点A成为node_id那个节点的从节点。并开始对从节点进行复制：

1. 修改节点A的`clusterNode.slaveof`属性
2. 修改`clusterState.myself.flags`属性, 关闭REDIS_NODE_MASTER打开REDIS_NODE_SLAVE，表示这个节点从主节点变为了从节点。
3. 对复制的节点进行复制操作。

某个节点变为某个节点从节点这一消息会发送给集群中的其他节点，最终会传遍整个集群。

### 2. 故障检测
集群中的节点会定期的向其他节点发送PING消息，收到消息的节点会返回PONG消息。以此来检测对方是否在线。如果接收者没有在规定时间内返回PONG，那么发送者将它标记为**疑似下线(PFAIL)**。

集群中的各个节点会相互发送消息来交换各个节点的状态信息，状态有：**在线**、**疑似下线**、**已下线**。当主节点A从主节点B得知C疑似下线后，A会在自己的`clusterState.nodes`中找到C的实例结构，然后再C的结构中找到**下线报告**`clusterNode.fail_reports`，并将B的下线报告报告添加进去。

一个集群里，半数以上，负责槽的主节点都将某个主节点x标记为疑似下线，则会有一个节点将x标记为已下线，并将这个消息在集群中广播，手打消息的节点也会将x标记为已下线。

### 3. 故障转移
1. 下线主节点的从节点里，会有一个从节点被选中。
2. 被选中的节点执行`SLAVEOF no one`，成为主节点。
3. 新主撤销旧主负责的槽，并将这些槽指派给自己。
4. 新主广播**PONG消息**，这个消息使其他节点知道新主上来了，并且接管了槽。
5. 新主开始接收请求，完成故障转移。

### 4. 选举新节点
1. 集群配置纪元，初值为0
2. 每次故障转移操作，纪元+1
3. 在每个配置纪元，每个主节点有一次投票机会，第一个向该节点申请票的从节点将得到它的投票
4. 从发现主下线时，向集群广播申请投票的消息。
5. 如果一个主的票还没有投，那么它就把票投给先发给它消息的那个从。
6. 拥有超过半数主节点数的票的从节点成为主节点。
7. 没有选举成功的话，就重新开启一个配置纪元，再次开始投票。

## 7、消息
集群中的各个节点通过收发消息来进行通信。
节点发送的消息主要有五种：

1. MEET消息：客户端向节点A发送`CLUSTER MEET`**命令**，节点A向目的节点发MEET**消息**，请求对方加入到集群。
2. PING消息：节点向集群中其他节点发送，来验证对方是否在线，接收节点的选取有一定规则，见书P281。
3. PONG消息：MEET和PING消息的回复，节点也可以广播发这个消息，让集群中其他节点更新对自己的认识。
4. FAIL消息：当节点A标记B已下线时，会广播这条消息，收到这条消息的节点也会把B标记已下线。
5. PUBLISH消息：节点收到PUBLISH**命令**时，会执行这个命令，并且在集群中广播PUBLISH消息，收到这个消息的节点也会执行这个PUBLISH命令。

### 1. 消息头
节点发送的消息都由一个消息头包裹，除了包含消息正文外，还记录了发送者的一些信息。消息头是`cluster.h/clusterMsg`结构。其中`data属性`指向一个union结构`cluster.h/clusterMsgData`，这就是消息正文。

### 2. MEET、PING、PONG消息实现
集群中的各个节点通过Gossip协议来交换不同节点的信息，由MEET、PING、PONG三种消息组成。每个消息的正文都由两个`cluster.h/clusterMsgDataGossip`结构组成。通过消息头中的`type`来判断消息类型。

每次发送这三种消息时，当前节点A都会从自己的已知列表中随机挑选出两个节点B和C，将他们的信息保存到`clusterMsgDataGossip`结构中发送出去，收到消息的节点，会更新自己对B和C的认识。

### 3. FAIL消息实现
当集群节点A发现B已下线时，会广播一条B下线的FAIL消息`clusterMsgDataFail`，这条消息只包含了B节点的名字。如果使用Gossip协议来广播会有延迟，直接用FAIL消息会快一点(我推测是因为Gossip协议的消息都比较大，而FAIL消息只有节点名，很小)。

### 4. PUBLISH消息实现
客户端向节点发送PUBLISH命令时，该节点会向集群广播PUBLISH消息，收到消息的节点也会执行这个命令。意思是客户端向服务器发送一条：

	PUBLISH <channel> <message>
那么集群中的每个节点都会向channel发送message。  
PUBLISH消息由`clusterMsgDataPublish`结构表示，包含频道和消息正文。
