# 第二章 简单动态字符串
redis没有用传统C字符串，而是构建了一种名为“简单动态字符串”(SDS,simple dynamic string)的抽象类型。
SDS是redis的默认字符串表示，在`<sds.h>`。
字符串键值对的键和值都是SDS。
传统C字符串不能满足redis对字符串安全性、效率以及功能方面的要求。<br>

1. SDS可以在O(1)复杂度取字符串长度，C字符串是O(N)
2. C字符串容易造成缓冲区溢出
3. C字符串增加或者截断经常需要重新分配内存，SDS有空间预分配和惰性空间释放两种策略。
4. C字符串会把'\0'当作结尾，这只能用来存字符串，不能用来处理二进制数据，SDS通过len可以实现存任意二进制数据。
5. SDS兼容C以'\0'为结尾的规则，这样就可以重用一部分string.h中的字符串函数

# 第三章 链表
C语言没有内置链表这种数据结构，所以redis构建了自己的链表。<br>
链表被广泛用于实现redis的各种功能，列表键、发布与订阅、慢查询、监视器等。redis服务器使用链表来保存多个客户端的信息。<br>
链表实现是`adlist.h`，这里的链表是双端链表，即链表节点包含前一个节点和后一个节点的指针。<br>
redis定义了链表结构，包含头尾节点、链表长度、和一些函数指针。
redis链表用void*保存值，并且链表中的函数指针应用于不同类型的数据，只用C语言就实现了保存不同的类型。

# 第四章 字典
字典，是一种用于保存键值对的抽象数据结构。字典中的每个键都是独一无二的。<br>
C语言没有字典这种数据结构，所以redis构建了自己的字典。<br>
redis数据库就是使用字典作为底层实现的，增删改查都是构建在对字典的操作上的。字典还是hash键的实现之一。
redis的字典使用hash表作为底层实现,字典的实现在`<dict.h>`。<br>
dictType结构保存了一簇用于操作特定类型键值对的函数.<br>
使用特定类型指定的hash函数对key进行hash计算,得到hash值和索引值,然后将包含新键值对的hash表节点放到hash数组的指定索引上。<br>
当字典用作数据库底层实现或者hash键的实现时,redis使用**MurmurHash2算法**来计算hash值。这种算法计算速度快,随机性好。<br>

redis的hash表使用**链地址法**来解决键冲突，插入表头O(1)，冲突时查询O(N)。<br>
为了让hash表的负载因子维持在一个合理的范围之内，当hash表中的键值对太多或太少时，对hash表进行扩展或收缩（rehash）。
扩大的话，将hash表扩大为>=used*2的第一个2^n，缩小的话，缩小为>=used的第一个2^n。<br>
**负载因子** = `used/hash_table_size`。注意used很有可能大于size的，因为每个索引上可能挂着多个hash节点。<br>
**渐进式rehash**,redis在对字典操作的过程中将ht[0]rehash到ht[1]上，而不是一次性rehash过去。

# 第五章 跳跃表
跳跃表是一种有序的数据结构，它通过在每个节点种维护多个指向其他节点的指针，从而达到快速访问的目的。平均`O(logN)`，最坏`O(N)`的复杂度进行查找。<br>
跳跃表在大多数情况下效率可以媲美平衡树，而且实现也比平衡树简单很多。<br>
redis只有**两个**地方用到了跳跃表，一个是有序集合键的实现，另一个是在集群节点种用作内部数据结构。<br>
跳跃表的实现在`<redis.h/zskiplist>`

# 第六章 整数集合
整数集合(intset)是集合键的底层实现之一。整数集合是redis用来保存整数值的集合抽象数据结构。
该结构定义于`<intset.h>`中。<br>
每添加一个新元素到整数集合时，新元素的类型比当前集合元素类型要长时，整数集合需要升级，然后才能将新元素添加进去。<br>
升级的好处，一个时提升整数集合的灵活性，另一个是尽可能地节约内存。
整数集合不支持降级操作。
整数集合的复杂度：插入和删除是O(N)，查找是O(logN)，其他事O(1)。

# 第七章 压缩列表
压缩列表(ziplist)是列表键和哈希键的底层实现之一。使用压缩列表的关键点：元素数量较少、列表项是小整数或者短字符串。<br>
压缩列表是redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意个节点。每个节点保存一个字节数组或者一个整数值。<br>
压缩列表从表尾到表头遍历，因为列表节点中有前一个节点的长度。
添加和删除节点可能会引发连锁更新。添加、删除和查找的平均复杂度是O(N)，最坏是O(N^2)。

# 第八章 对象
redis并没有直接用前面介绍的那么多数据结构来实现键值对数据库，而是在基于这些数据结构创建了一个**对象系统**，包含字符串、列表、哈希、集合和有序集合**五种对象**，每种对象都用到了**至少一种**前面介绍的数据结构。redis的对象系统还实现了基于**引用计数**的内存回收机制。<br>
redis中用两个对象来表示键值对，键对象和值对象。

对象结构体中包含了type、encoding、ptr属性。<br>
键总是字符串对象，而值是五种对象其中的一种。
对键执行type命令返回的是其值的类型，而不是键的类型。
ptr指向具体的数据结构，encoding指示使用的是什么数据结构。<br>
每种对象都至少可以使用两种不同的编码,object encoding key命令可以查看键对应的值是什么编码。<br>
当使用一种编码不能满足需要时，会转换成其他编码。<br>
##
**字符串对象**可以使用int、raw、embstr三种编码。<br>
字符串对象是唯一一种会被其他四种对象嵌套的对象。
embstr是用来保存短字符串的。可以用long(32位)类型保存的整数中int存。<br>
**列表对象**的编码可以是ziplist和linkedlist。<br>
我在对一个列表对象查看编码时，发现是"quicklist"，A doubly linked list of ziplists。这个是在3.2版本新增的。虽然现在已经改为用quicklist了，还是记录一下之前两种结构的用法：
当不能满足ziplist时，会转换为linkedlist。
使用ziplist的条件：

1. 所有字符串元素长度小于64字节
2. 列表长度小于512

**哈希对象**的编码可以是ziplist和hashtable。<br>
用ziplist保存时，是先推入键对象，在推入值对象。两个对象挨着。
hashtable编码的对象使用字典作为底层实现。<br>
使用ziplist的条件同列表对象。
**集合对象**的编码可以是intset和hashtable。<br>
使用intset的条件：

1. 保存的都是整数
2. 元素数量小于512

使用hashtable编码，底层用字典实现，字典的值对象设为NULL。<br> 
**有序集合对象**的编码可以是ziplist和skiplist。<br>
ziplist使用挨在一起的两个压缩列表节点存储成员和分数。在ziplist中按照分值从小到大排序。<br>
skiplist编码使用zset数据结构来实现，zset中包含一个字典dict和一个跳跃表zsl。
zsl按分值大小保存了所有集合元素，跳跃表节点的object属性保存成员，score属性保存分值。通过跳跃表可以对集合进行范围型操作。<br>
dict保存了成员到分值的映射，使得从成员获取分值的操作可以O(1)的复杂度完成。<br>
虽然使用了zsl和dict两个数据结构来存储内容，但是字符串对象都是共享的，所以不会有存储空间的浪费。

使用ziplist的条件：

1. 有序集合保存的元素数量小于128个
2. 所有元素成员长度都小于64


**为什么有序集合需要同时使用跳跃表和字典来实现？**

理论上来说确实可以只使用其中一种来实现，但无论是单独使用哪一种，在性能上肯定不如使用两种效率高。为了范围操作和根据成员查找分值操作的效率都好，所以使用了两种。
##
redis用于操作命令的键基本上可以分为两种类型。

1. 可以应用于任何类型的键，例如del、rename、type等。基于类型的多态
2. 只能应用于特定类型的键，例如set、hset、sadd等。基于编码的多态

在执行一个命令前服务器会先检查值对象是否为所执行命令的所需要的对象。不是的话拒绝执行，返回错误。<br>
除了判断键是否能执行该命令外，还会根据值对象的编码选择不同的执行代码，就像C++的多态。<br>
通过引用计数实现内存回收和共享对象。共享对象可以节省大量的内存。
redis服务器在启动时会创建0-9999这一万个字符串对象，来被共享使用。object refcount key。可以查看key对应的值的引用计数。<br>
**redis不共享包含字符串的对象，只共享包含整数值字符串的对象。因为验证两个对象是否完全相等需要时间，整数O(1),字符串O(N)，如果字符串很长，验证这一步消耗的时间太多。**<br>
对象中还包含闲lru属性，记录该对象最后一次被访问的时间。OBJECT IDLETIME KEY 命令查看对象空转/闲置时长，是通过当前时间-lru得到的。<br>
如果服务器打开了maxmemory选项，当达到内存上限时，会根据一定的策略把空转时间较长的对象释放回收内存。
