# 第十八章 发布与订阅
客户端可以订阅一个或多个频道，成为这些频道的订阅者；每当有其他客户端向该频道发消息时，订阅者就可以接收到。

## 1、频道的订阅与退订
执行`SUBSCRIBE`命令订阅某个或某些频道，这个客户端与被订阅频道之间就建立起了一种订阅关系。  
服务端**所有**频道的订阅关系都保存在`redisServer.pubsub_channels`字典中，键是频道名字，值是订阅该频道的客户端组成的链表。

	SUBSCRIBE <channels>
当客户端执行订阅命令时，服务端会把这个新的订阅关系插入到上面那个字典中。
	
	UNSUBSCRIBE <channels>
当客户端执行退订命令时，服务端会把这个订阅关系从上面的字典中删除。

## 2、模式的订阅与退订
服务端**所有**的模式订阅关系都保存在`redisServer.pubsub_patterns`链表中，链表中的值是`pubsubPattern`结构。该结构记录了客户端和模式。

	PSUBSCRIBE <patterns>
当客户端执行订阅模式命令时，服务端会为每个订阅的模式创建pubsubPattern结构，填充内容后放到模式链表的结尾。

	PUNSUBSCRIBE <patterns>
当客户端执行退订模式命令时，服务端会根据模式和客户端两个属性去`pubsub_patterns`中找到那个链表节点，然后把它删掉。

## 3、发送消息
客户端执行以下命令，将message发给channel：

	PUBLISH	<channel> <message>
### 1. 发送给频道订阅者
在`redisServer.pubsub_channels`字典中找到频道订阅者的那个链表，然后将消息一一发送给他们

### 2. 发送给模式订阅者
消息发送给订阅者**后**，遍历模式链表，找到与频道相匹配的模式，将消息发送给订阅了这个模式的客户端。

## 4、查看订阅信息
客户端可以通过`PUBSUB`命令来查看频道或者模式的相关信息。
### 1. PUBSUB CHANNELS
这个子命令可以查看当前的频道信息：

	PUBSUB CHANNELS [pattern]
1. 如果不加pattern，则显示所有频道
2. 加了pattern则显示能匹配pattern的频道

### 2. PUBSUB NUMSUB
返回指定频道订阅者的数量

	PUBSUB NUMSUB [channe-1 channe-2 channe-3 ... channe-N]
每个频道返回两行

	channel—name
	sub-number
### 3. PUBSUB NUMPAT
返回服务器当前被订阅模式的数量，即返回`pubsub_patterns`链表的长度。

# 第十九章 事务
事物提供了一种将多个命令打包，一次性、按顺序的执行多个命令的机制。并且在执行期间不会被打断，处理完当前事务才回去执行其他命令。  
事务由MULTI、EXEC、WATCH等命令来实现。
## 1、事务的实现
包含三个阶段。
### 1. 事务开始

	MULTI
执行这个命令后，将客户端的状态从非事务状态切换成事务状态，修改REDIS_MULTI标志。
### 2. 命令入队
当客户端处于事务状态时：

1. 如果命令是EXEC、DISCARD、WATCH、MULTI则立即执行。
2. 否则服务端将把这个命令放入一个事务队列中，返回QUEUED。

### 3. 事务队列 
每个客户端都有自己的事务状态，保存在`redisClient.mstate`中。事务状态包含一个事务队列和队列长度。事务队列是一个`multiCmd`类型的数组，这个类型包括了函数指针、参数数量、参数。

### 4. 执行事务
当一个处于事务状态的客户端发送EXEC命令时，服务端将立即遍历客户端的事务队列，执行队列中的所有命令，最后将所有执行结果返回给客户端，同时将事务状态切换为非事务状态。

## 2、WATCH命令的实现
WATCH命令是一个乐观锁，它在执行EXEC命令之前，监视任意数量的数据库键，并在EXEC执行时，检查是否至少有一个键被修改。如果是的话，服务器将拒绝执行事务并返回空。

每个redis数据库都保存着一个`watched_keys`字典，键是某个被WATCH的数据库键，值是一个链表记录了监视该键的客户端。每当执行一个写命令后，都会调用`multi.c/touchWatchedKey`函数来检查操作的键是否被WATCH，如果是的话，则将WATCH该键的客户端的`REDIS_DIRTY_CAS`标识打开，标识客户端的事务安全性已破坏。

当客户端EXEC执行事务时，如果发现`REDIS_DIRTY_CAS`被打开，那么拒绝执行，否则正常执行。

## 3、事务的ACID性质
传统关系数据库中常常用ACID性质来检验事务功能的可靠性和安全性。在redis中事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），当redis运行在某些持久化模式下时，事务也具有耐久性（Durability）。
### 1. 原子性
将事务当作一个整体，要么都执行，要么都不执行。  
redis事务和传统数据库的事务的**最大区别**在于：redis事务不支持回滚。即使有命令出错，也会继续执行下去，直到执行完毕。  
redis的作者认为事务回滚过于复杂，和redis追求简单高效的主旨不符合。并且它认为事务出错一般是在开发环境中，生产环境很少出现，所以没有必要增加回滚。
### 2. 一致性
事务一致性指的是，数据库在事务执行前是一致的，在执行后必定也是一致的。  
一致是指：数据符合数据库本身的定义和要求，没有包含非法或者无效的数据。  
下面是几个redis事务可能出错的地方：

1. 入队错误：在入队过程中检查到命令有错误，例如命令不存在，那么redis将拒绝执行这个事务。
2. 执行错误：都是一些在入队时不能被发现的错误。即使在事务执行过程出现了执行错误，事务也不会停止，而是继续执行完后面的命令。
3. 服务器停机：有以下几种情况：
	1. 服务器无持久化，重启后还是空白的，空白数据库总是一致的。
	2. RDB或者AOF持久化模式，重启后会根据现有的持久化文件来恢复数据库，不会影响一致性。
### 3. 隔离性
隔离性是指：即使同时有多个事务在并发执行，各个事务之间也不会相互影响。redis使用单线程的方式执行事务，是以串行方式来执行的，所以总是具有隔离性的。
### 4. 耐久性
事务的耐久性指的是：在事务执行完毕后，就已经被持久化保存了，即使此时宕机，数据也不会有问题。redis的事务只是简单的用队列包装了一下，并没有为事务提供额外的持久化功能。所以redis的耐久性和持久化模式有关：

1. 没有持久化，事务不具备耐久性：一旦停机所有数据都丢失
2. RDB持久化模式下，数据保存具有一定的条件，不能保证事务执行完会被持久化。所以RDB模式也不能保证耐久性。
3. AOF持久化模式下，appendsync选项设置为always时，能保证耐久性。为everysec和no时不能保证耐久性。

# 第二十章 Lua脚本
2.6版本开始引入了对Lua脚本的支持，通过在服务端中内嵌了一个Lua环境。redis客户端可以使用Lua脚本直接在服务端原子地执行多个redis命令。

不看这一章了。

# 第二十一章 排序
redis的SORT可以对列表键、集合键和有序集合的值进行排序。
## 1、SORT <key>命令的实现
最简单形式如下：

	SORT <key>
排序列表键时的步骤如下：

1. 创建一个和key列表长度相同的数组，其中每个元素都是一个`redis.h/redisSortObject`。
2. 遍历数组使得各个数组项的obj指针分别指向key列表的每个项，构成一一对应关系。
3. 遍历数组，将各个obj指针指向的对象**转换**成一个**double**类型存到`redisSortObjectu.score`里。
4. 根据数组项的u.score对组数排序，排序后u.score值从小到大排列。
5. 遍历数组，按照顺序把obj指针指向的对象返回给客户端。

## 2、ALPHA选项
通过使用ALPHA选项，可以对包含字符串值的键进行排序：

	SORT <key> ALPHA
排序步骤和`1`中类似，只是排序规则由“转换为double再排序”变为按照字符串大小排序。

## 3、ASC选项和DESC选项
默认情况下排序结果是升序的，也就是默认是ASC。

	SORT <key> [ASC or DESC]
升序和降序都是由相同快速排序算法执行，不同之处在于排序算法使用的**对比函数**产生的结果不同。

## 4、BY选项
默认情况下使用排序元素本身的值作为排序的权重。通过使用BY选项，可以指定某些字符串键作为元素的权重来进行排序。
	
	SORT <key> BY <pattern>
排序规则如下：

1. 遍历数组，根据obj指针所指元素的键和by选项所指定的模式，查找相应的权重键
2. 将找到的权重键转换为一个double，存到u.score中，按照这个值进行排序。

## 5、BY选项+ALPHA选项
BY选项默认假设权重键保存的是数值型，如果是字符串型的话，需要加上ALPHA
	
	SORT <key> BY <pattern> ALPHA
排序规则如下：

1. 遍历数组，根据obj指针所指元素的键和by选项所指定的模式，查找相应的权重键
2. 将找到的权重键的字符串存到u.comobj中，按照这个值进行字符串排序。

## 6、LIMIT选项
默认情况下，排序后会将所有结果都返回给客户端。可以通过LIMIT选项使得只返回一部分元素：

	SORT <key> LIMIT <offset> <count>
1. offset表示要跳过几个元素
2. count表示要返回的元素个数

## 7、GET选项
默认情况下，排序后总是返回被排序键本身所包含的元素。可以通过GET选项使得在返回结果时，根据被排序元素的值和指定的模式，查找并返回某些键的值。

	SORT <key> ALPHA GET <pattern>
在返回结果的时候，不是直接返回给客户端，而是根据obj指向的元素，以及GET选项指定的模式查找相应的键并返回其值。并且可以指定**多个GET选项**，那么排序后的每个元素会相应的去查找多个值并返回。

## 8、STORE选项
默认情况下，排序后只是返回结果给客户端，并不保存排序结果。通过STORE选项，可以将排序结果保存到指定的键里。

	SORT <key> STORE <new_key>
排完序后，在返回结果之前增加一步：
检查new_key是否存在，如果存在删除掉。新增new_key列表键，将排序的结果存入new_key中。

## 9、多个选项的执行顺序
实际情况中使用SORT通常会指定多个选项，这些选项是有先后执行顺序的。  
按照SORT的执行顺序可以分为这么几类：

1. 排序：ALPHA、ASC、DESC、BY
2. 限制排序结果长度：LIMIT
3. 获取外部键：GET
4. 保存排序结果：STORE
5. 返回结果给客户端。

SORT的执行顺序就是按照这个顺序来的。

除了GET选项外，其他选项的位置都是可以随意调换的。如果指定了多个GET选项，那么在调换顺序时，各个GET选项之间的位置不能随意调换，否则结果会不同。

# 第二十二章 二进制位数组
redis提供了二进制位数组的功能，类似C++的bitset。  
redis使用其数据结构SDS来表示位数组，它是二进制安全的，随便用。SDS的每个字符可以存8个二进制位。  
获取某个二进制位的命令：

	GETBIT <key> <offset>
通过对offset进行简单的计算，可以在O(1)的时间内得到该二进制位是什么。

设置一个二进制位的命令：

	SETBIT <key> <offset> <value>
value的值只能是0或1否则报错。同样setbit命令也只需O(1)的时间即可。
如果设置的偏移量计算出的字节号超过了SDS现在所拥有的字节数，那么就按照SDS的规则扩大空间。

统计二进制位数组的1的数目：

	BITCOUNT <key>
这个实现是有一些技巧的，下面是统计二进制位中1的一些算法：

1. 遍历检查某个位是否为1。时间复杂度无法接受。
2. 查表，提前打表某个数字中的1的个数，额外内存空间可能会高。
3. 统计二进制位中1的个数，这个问题也被叫做**计算汉明重量**。**variable-precision SWAR算法**可以在常数时间内计算多个字节的汉明重量，并且不需要额外内存。算法详情见书P374。
4. redis的实现是结合了2和3的算法。对0-127的数字打表，如果当前未计算的字节数小于4那么就查表，如果大于4那么每次取4个字节，128位进行计算。

二进制位数组还支持逻辑操作，都是调用C语言自带的逻辑操作。逻辑操作的命令如下：

	BITOP <AND> <result_key> <key1> <key2>
	BITOP <OR> <result_key> <key1> <key2>
	BITOP <XOR> <result_key> <key1> <key2>
	BITOP <NOT> <result_key> <key>

# 第二十三章 慢查询日志
redis慢查询日志用于记录执行时间超过给定时长的请求。用户可以通过这个功能来监视和优化查询速度。
redis配置中慢查询相关选项：

1. `slowlog-log-slower-than`超过这个时长的命令会被记录下来，单位是微秒。
2. `slowlog-max-len`最多保存多少条日志。

redis使用先进先出的方式保存慢查询日志。查看慢查询日志：

	SLOWLOG GET
redisServer中保存了几个和慢查询日志相关的属性：

	slowlog_entry_id	下一条慢查询日志的ID
	slowlog				保存了所有慢查询日志的链表
	slowlog_log_slower_than 服务器配置 
	slowlog_max_len		服务器配置
slowlog链表中的每个节点保存了一个`slowlog.h/slowlogEntry`结构，里面记录了一条命令的相关信息。

查看slowlog日志数量：

	SLOWLOG LEN
`slowlog.c/slowlogPushEntryIfNeeded`这个函数是用来添加slowlog的。

# 第二十四章 监视器
通过`MONITER`命令，客户端可以将自己变为一个监视器，实时的接受并打印出服务器当前在处理的命令。原理是服务器接收一条命令后不仅执行它，还会把这条命令发送给各个监视器。

`redisServer.monitors`链表中保存了所有的监视器，每当一个客户端成为监视器就把它加入到这个链表中，并且把该客户端的REDIS_MONITER标志打开

`replication.replicationFeedMonitors`这个函数用来把消息发送给客户端。